<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BiaScan</title>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background: linear-gradient(135deg, #cae14c 0%, #39ecec 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 1fr 350px;
    gap: 20px;
}

.main {
    background: white;
    border-radius: 12px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.sidebar {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    max-height: 800px;
    overflow-y: auto;
}

h1 {
    color: #333;
    margin-bottom: 10px;
    font-size: 28px;
    text-align: center;
}

.subtitle {
    color: #666;
    margin-bottom: 25px;
    font-size: 14px;
}

.input-group {
    margin-bottom: 20px;
}

label {
    display: block;
    color: #555;
    font-weight: 600;
    margin-bottom: 8px;
    font-size: 13px;
}

input[type="file"], textarea {
    width: 100%;
    padding: 12px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-family: inherit;
    font-size: 14px;
    transition: border-color 0.3s;
}

input[type="file"]:focus, textarea:focus {
    outline: none;
    border-color: #667eea;
}

textarea {
    height: 300px;
    resize: vertical;
    font-family: 'Monaco', 'Courier New', monospace;
}

.button-group {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

button {
    flex: 1;
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
}

#scanBtn {
    background: linear-gradient(135deg, #24d76f 0%, #1e4dce 100%);
    color: white;
}

#scanBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
}

#scanBtn:active {
    transform: translateY(0);
}

#clearBtn {
    background: #f5f5f5;
    color: #333;
}

#clearBtn:hover {
    background: #eeeeee;
}

#output {
    margin-top: 30px;
    padding: 20px;
    background: #fafafa;
    border-radius: 8px;
    line-height: 1.8;
    min-height: 200px;
    color: #333;
}

.highlight {
    padding: 2px 6px;
    border-radius: 4px;
    cursor: help;
    position: relative;
    font-weight: 500;
    transition: opacity 0.2s;
}

.highlight:hover {
    opacity: 0.8;
}

.grey { background-color: #737f8a; color: #fff; }
.yellow { background-color: #ffeb3b; color: #fff; }
.orange { background-color: #ff9800; color: #fff; }
.red { background-color: #f44336; color: #fff; }

.tooltip {
    position: relative;
}

.tooltip:hover::after {
    content: attr(data-tip);
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 13px;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
}

.tooltip:hover::before {
    content: '';
    position: absolute;
    bottom: 115%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: #222;
    z-index: 100;
}

.results-header {
    color: #667eea;
    font-weight: 700;
    margin-bottom: 15px;
    font-size: 15px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.result-item {
    background: #f9f9f9;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 10px;
    border-left: 4px solid #667eea;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}

.result-item:hover {
    background: #f0f0f0;
    transform: translateX(4px);
}

.result-type {
    display: inline-block;
    background: #667eea;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 4px;
}

.result-reason {
    color: #666;
    margin-top: 4px;
    font-size: 12px;
}

.result-severity {
    display: inline-block;
    margin-top: 4px;
    font-size: 11px;
    color: #999;
}

.result-text {
    margin-bottom: 6px;
    font-weight: 600;
    font-size: 13px;
}

.result-text .highlight {
    padding: 1px 3px;
    border-radius: 2px;
    font-weight: 600;
}

.loading {
    text-align: center;
    color: #999;
    padding: 20px;
    font-size: 13px;
}

.empty-state {
    text-align: center;
    color: #999;
    padding: 30px 20px;
    font-size: 13px;
}

@media (max-width: 1024px) {
    .container {
        grid-template-columns: 1fr;
    }
    
    .sidebar {
        max-height: none;
    }
}

/* Loading Overlay */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.loading-overlay.show {
    opacity: 1;
    visibility: visible;
}

.loading-modal {
    background: white;
    border-radius: 12px;
    padding: 30px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    max-width: 400px;
    width: 90%;
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-text {
    color: #333;
    font-size: 16px;
    margin-bottom: 20px;
    font-weight: 500;
}

.progress-container {
    width: 100%;
    background: #f0f0f0;
    border-radius: 10px;
    height: 8px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    border-radius: 10px;
    width: 0%;
    animation: progress 2s ease-in-out infinite;
}

@keyframes progress {
    0% { width: 0%; }
    50% { width: 70%; }
    100% { width: 100%; }
}

.loading-subtext {
    color: #666;
    font-size: 14px;
    font-style: italic;
}
</style>
</head>

<body>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-modal">
        <div class="loading-spinner"></div>
        <div class="loading-text">Analyzing text for bias...</div>
        <div class="progress-container">
            <div class="progress-bar"></div>
        </div>
        <div class="loading-subtext">This may take a few seconds</div>
    </div>
</div>

<div class="container">
    <div class="main">
        <h1>BiaScan</h1>
        <p class="subtitle">Using this tool, you can find out if any of your text contains any bias, be that political, emotional, or otherwise, and it will highlight and explain each portion containing the bias</p>

        <div class="input-group">
            <label for="fileInput">Load File</label>
            <input type="file" id="fileInput" accept=".txt">
        </div>

        <div class="input-group">
            <label for="text">Text to Analyze</label>
            <textarea id="text" placeholder="Paste your text here..."></textarea>
        </div>

        <div class="button-group">
            <button id="scanBtn" onclick="scan()">Scan for Bias</button>
            <button id="clearBtn" onclick="clearAll()">Clear</button>
        </div>

        <div id="output" class="empty-state">Results will appear here...</div>
    </div>

    <div class="sidebar">
        <div class="results-header">Findings</div>
        <div id="results-list" class="empty-state">No results yet</div>
    </div>
</div>

<script>
let currentResults = [];

document.getElementById("fileInput").addEventListener("change", function () {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => {
        document.getElementById("text").value = e.target.result;
    };
    reader.readAsText(file);
});

async function scan() {
    const text = document.getElementById("text").value;
    if (!text.trim()) {
        alert("Please enter some text to scan");
        return;
    }

    // Show loading overlay
    document.getElementById("loadingOverlay").classList.add("show");

    document.getElementById("scanBtn").disabled = true;
    document.getElementById("scanBtn").textContent = "Scanning...";

    try {
        const res = await fetch("/scan", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text })
        });

        const data = await res.json();
        currentResults = data.results || [];
        render(text, currentResults);
        updateResultsList(currentResults);
    } finally {
        // Hide loading overlay
        document.getElementById("loadingOverlay").classList.remove("show");

        document.getElementById("scanBtn").disabled = false;
        document.getElementById("scanBtn").textContent = "Scan for Bias";
    }
}

function clearAll() {
    document.getElementById("text").value = "";
    document.getElementById("output").innerHTML = '<div class="empty-state">Results will appear here...</div>';
    document.getElementById("results-list").innerHTML = '<div class="empty-state">No results yet</div>';
    currentResults = [];
}

function severityColor(sev) {
    if (sev < 0.5) return "grey";
    if (sev > 0.5 && sev < 0.75) return "yellow";
    if (sev > 0.75 && sev < 1.0) return "orange";
    return "red";
}

function updateResultsList(results) {
    const list = document.getElementById("results-list");
    if (results.length === 0) {
        list.innerHTML = '<div class="empty-state">No bias detected ✓</div>';
        return;
    }

    list.innerHTML = results.map((r, i) => `
        <div class="result-item">
            <div class="result-text">
                <span class="highlight ${severityColor(r.severity)}">${escapeHTML(r.text)}</span>
            </div>
            <div class="result-type">${r.type}</div>
            <div class="result-reason">${escapeHTML(r.reason)}</div>
            <div class="result-severity">Severity: ${(r.severity * 100).toFixed(0)}%</div>
        </div>
    `).join("");
}

function render(text, results) {
    if (results.length === 0) {
        document.getElementById("output").innerHTML = '<div class="empty-state">No bias detected in this text ✓</div>';
        return;
    }

    let html = escapeHTML(text);

    // Sort results by the position they appear in the text (to avoid conflicts when replacing)
    results.sort((a, b) => {
        const posA = findBestMatchPosition(text, a.text);
        const posB = findBestMatchPosition(text, b.text);
        return posA - posB;
    });

    // Replace each problematic text with highlighted version
    for (const r of results) {
        const match = findBestMatch(text, r.text);
        if (match) {
            const escapedMatch = escapeHTML(match);
            const highlighted = `<span class="highlight ${severityColor(r.severity)} tooltip" data-tip="Suggestion: ${escapeHTML(r.suggestion)}">${escapedMatch}</span>`;
            // Use global replace to handle multiple occurrences
            const regex = new RegExp(escapedMatch.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            html = html.replace(regex, highlighted);
        }
    }

    document.getElementById("output").innerHTML = html;
}

// Find the best match for the AI-extracted text in the original text
function findBestMatch(originalText, extractedText) {
    // First try exact match
    if (originalText.includes(extractedText)) {
        return extractedText;
    }

    // Try without leading/trailing punctuation
    const cleanedExtracted = extractedText.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, '');
    if (originalText.includes(cleanedExtracted)) {
        return cleanedExtracted;
    }

    // Try to find as substring with word boundaries
    const words = cleanedExtracted.split(/\s+/);
    if (words.length > 0) {
        // Look for the longest sequence of words that appears in the text
        for (let i = words.length; i > 0; i--) {
            for (let j = 0; j <= words.length - i; j++) {
                const phrase = words.slice(j, j + i).join(' ');
                if (originalText.includes(phrase)) {
                    return phrase;
                }
            }
        }
    }

    // Last resort: return the extracted text as-is (might not match but at least shows something)
    return extractedText;
}

// Find the position of the best match for sorting
function findBestMatchPosition(originalText, extractedText) {
    const match = findBestMatch(originalText, extractedText);
    return originalText.indexOf(match);
}

function escapeHTML(s) {
    return s.replace(/[&<>"']/g, c => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;",
        "'": "&#39;"
    })[c]);
}
</script>

</body>
</html>
